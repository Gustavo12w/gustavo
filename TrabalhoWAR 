

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_NOME 30
#define MAX_COR 10
#define MAX_MISSAO 100

// Estrutura de dados principal
typedef struct {
    char nome[MAX_NOME];
    char cor[MAX_COR];
    int tropas;
} Territorio;

// ====================== PROT√ìTIPOS ====================== //
Territorio* cadastrarTerritorios(int quantidade);
void exibirTerritorios(Territorio* mapa, int quantidade);
void atacar(Territorio* atacante, Territorio* defensor);
void liberarMemoria(Territorio* mapa, char** missoesJogadores, int numJogadores);
void atribuirMissao(char* destino, char* missoes[], int totalMissoes);
int verificarMissao(char* missao, Territorio* mapa, int tamanho);
int lerInteiro(const char* mensagem, int min, int max);

// ====================== FUN√á√ÉO PRINCIPAL ====================== //
int main() {
    srand((unsigned int)time(NULL)); // Gera aleatoriedade para miss√µes e ataques

    printf("=== Sistema WAR com Miss√µes Estrat√©gicas ===\n\n");

    int numTerritorios = lerInteiro("Informe a quantidade de territ√≥rios (>=5): ", 5, 1000);
    int numJogadores = lerInteiro("Informe o n√∫mero de jogadores (1-4): ", 1, 4);

    // Aloca dinamicamente os territ√≥rios
    Territorio* mapa = cadastrarTerritorios(numTerritorios);
    if (mapa == NULL) {
        fprintf(stderr, "Erro ao alocar territ√≥rios.\n");
        return 1;
    }

    // Vetor de miss√µes poss√≠veis
    char* missoesPossiveis[] = {
        "Conquistar 3 territ√≥rios seguidos.",
        "Eliminar todas as tropas da cor vermelha.",
        "Controlar todos os territ√≥rios azuis.",
        "Possuir pelo menos 5 territ√≥rios com mais de 10 tropas.",
        "Ter o dobro de tropas do que qualquer outro jogador."
    };
    int totalMissoes = sizeof(missoesPossiveis) / sizeof(missoesPossiveis[0]);

    // Aloca dinamicamente as miss√µes para cada jogador
    char** missoesJogadores = (char**) malloc(numJogadores * sizeof(char*));
    for (int i = 0; i < numJogadores; i++) {
        missoesJogadores[i] = (char*) malloc(MAX_MISSAO * sizeof(char));
        atribuirMissao(missoesJogadores[i], missoesPossiveis, totalMissoes);
    }

    // Exibe as miss√µes apenas uma vez (no in√≠cio)
    for (int i = 0; i < numJogadores; i++) {
        printf("\nJogador %d, sua miss√£o √©: %s\n", i + 1, missoesJogadores[i]);
    }

    // Loop do jogo (simplificado)
    int opcao, vencedor = -1;
    do {
        printf("\n--- MENU ---\n");
        printf("1. Exibir territ√≥rios\n");
        printf("2. Realizar um ataque\n");
        printf("0. Sair\n");
        opcao = lerInteiro("Escolha uma op√ß√£o: ", 0, 2);

        if (opcao == 1) {
            exibirTerritorios(mapa, numTerritorios);
        } 
        else if (opcao == 2) {
            exibirTerritorios(mapa, numTerritorios);
            int idxAtacante = lerInteiro("N√∫mero do territ√≥rio atacante: ", 1, numTerritorios) - 1;
            int idxDefensor = lerInteiro("N√∫mero do territ√≥rio defensor: ", 1, numTerritorios) - 1;

            if (idxAtacante == idxDefensor) {
                printf("Erro: atacante e defensor n√£o podem ser o mesmo territ√≥rio.\n");
                continue;
            }

            Territorio* atacante = &mapa[idxAtacante];
            Territorio* defensor = &mapa[idxDefensor];

            if (strcmp(atacante->cor, defensor->cor) == 0) {
                printf("Erro: n√£o pode atacar territ√≥rio da mesma cor.\n");
                continue;
            }

            atacar(atacante, defensor);

            // Verifica√ß√£o de miss√µes ap√≥s o ataque
            for (int i = 0; i < numJogadores; i++) {
                if (verificarMissao(missoesJogadores[i], mapa, numTerritorios)) {
                    vencedor = i;
                    break;
                }
            }

            if (vencedor != -1) {
                printf("\nüéâ O Jogador %d cumpriu sua miss√£o e venceu o jogo!\n", vencedor + 1);
                break;
            }
        }

    } while (opcao != 0);

    liberarMemoria(mapa, missoesJogadores, numJogadores);
    printf("\nJogo encerrado.\n");
    return 0;
}

// ====================== FUN√á√ïES AUXILIARES ====================== //

// Fun√ß√£o para cadastrar territ√≥rios dinamicamente
Territorio* cadastrarTerritorios(int quantidade) {
    Territorio* mapa = (Territorio*) calloc(quantidade, sizeof(Territorio));
    if (mapa == NULL) return NULL;

    printf("\n=== Cadastro de Territ√≥rios ===\n");
    for (int i = 0; i < quantidade; i++) {
        printf("\nTerrit√≥rio %d:\n", i + 1);
        printf("  Nome: ");
        scanf(" %[^\n]", mapa[i].nome);

        printf("  Cor do ex√©rcito: ");
        scanf(" %[^\n]", mapa[i].cor);

        mapa[i].tropas = lerInteiro("  Tropas iniciais: ", 0, 1000);
    }
    return mapa;
}

// Exibe informa√ß√µes dos territ√≥rios
void exibirTerritorios(Territorio* mapa, int quantidade) {
    printf("\n=== Territ√≥rios Atuais ===\n");
    for (int i = 0; i < quantidade; i++) {
        printf("[%2d] Nome: %-20s | Cor: %-8s | Tropas: %d\n",
               i + 1, mapa[i].nome, mapa[i].cor, mapa[i].tropas);
    }
}

// Simula um ataque usando rand()
void atacar(Territorio* atacante, Territorio* defensor) {
    printf("\n%s (%s) atacando %s (%s)\n",
           atacante->nome, atacante->cor, defensor->nome, defensor->cor);

    int dadoA = (rand() % 6) + 1;
    int dadoD = (rand() % 6) + 1;

    printf("Rolagem atacante: %d | Rolagem defensor: %d\n", dadoA, dadoD);

    if (dadoA > dadoD) {
        int transferidas = atacante->tropas / 2;
        if (transferidas < 1) transferidas = 1;
        defensor->tropas += transferidas;
        atacante->tropas -= transferidas;
        strcpy(defensor->cor, atacante->cor);
        printf("Vit√≥ria do atacante! %s agora pertence ao ex√©rcito %s.\n",
               defensor->nome, defensor->cor);
    } else {
        atacante->tropas -= 1;
        printf("Defensor resistiu! Atacante perdeu 1 tropa.\n");
    }
}

// Sorteia uma miss√£o e copia para destino (por refer√™ncia)
void atribuirMissao(char* destino, char* missoes[], int totalMissoes) {
    int indice = rand() % totalMissoes;
    strcpy(destino, missoes[indice]);
}

// Verifica se uma miss√£o foi cumprida (l√≥gica inicial e gen√©rica)
int verificarMissao(char* missao, Territorio* mapa, int tamanho) {
    // Exemplo simples de verifica√ß√£o: se o jogador controla >=3 territ√≥rios da mesma cor
    // Essa l√≥gica pode ser expandida conforme o texto da miss√£o
    if (strstr(missao, "Conquistar 3 territ√≥rios") != NULL) {
        char corRef[MAX_COR];
        strcpy(corRef, mapa[0].cor);
        int cont = 0;
        for (int i = 0; i < tamanho; i++) {
            if (strcmp(mapa[i].cor, corRef) == 0) cont++;
        }
        return cont >= 3;
    }
    // Demais miss√µes podem ser ajustadas com regras pr√≥prias
    return 0;
}

// Libera toda a mem√≥ria alocada dinamicamente
void liberarMemoria(Territorio* mapa, char** missoesJogadores, int numJogadores) {
    if (mapa != NULL) free(mapa);
    if (missoesJogadores != NULL) {
        for (int i = 0; i < numJogadores; i++) {
            if (missoesJogadores[i] != NULL)
                free(missoesJogadores[i]);
        }
        free(missoesJogadores);
    }
}

// L√™ e valida inteiros
int lerInteiro(const char* mensagem, int min, int max) {
    int valor;
    while (1) {
        printf("%s", mensagem);
        if (scanf("%d", &valor) == 1 && valor >= min && valor <= max)
            return valor;
        printf("Valor inv√°lido. Tente novamente.\n");
        while (getchar() != '\n');
    }
}
